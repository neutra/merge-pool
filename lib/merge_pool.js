// Generated by CoffeeScript 1.6.2
(function() {
  var MergePool, async, util, _log,
    __slice = [].slice;

  util = require('util');

  async = require('async');

  _log = function(text) {
    return console.log("MergePool: " + text);
  };

  MergePool = (function() {
    /*
    	Merge Pool
    
    	merge multi requests, process one and response all the same requests
    */
    function MergePool(opt) {
      if (opt == null) {
        opt = {};
      }
      /*
      		constructor
      		> @opt:
      		>	debug:
      */

      this.pendings = {};
      this.debug = !!opt.debug;
    }

    MergePool.prototype.run = function() {
      var args, callback, done, err, exec, item, key, queue, _i,
        _this = this;

      key = arguments[0], exec = arguments[1], args = 4 <= arguments.length ? __slice.call(arguments, 2, _i = arguments.length - 1) : (_i = 2, []), callback = arguments[_i++];
      /*
      		run(key,exec,args...,callback)
      		> @key: string()
      		> @exec: (args...,callback) -> void()
      		> @callback: (err,result) -> void()
      */

      if (key == null) {
        throw new Error('MergePool.run: key can not must be null');
      }
      if ('string' !== typeof key) {
        key = key.toString();
      }
      if ('function' !== typeof exec) {
        throw new Error('MergePool.run: exec must be a function');
      }
      if ('function' !== typeof callback) {
        throw new Error('MergePool.run: callback must be a function');
      }
      item = {
        callback: callback
      };
      queue = this.pendings[key];
      if (queue != null) {
        queue.push(item);
        return;
      }
      queue = [item];
      this.pendings[key] = queue;
      done = function(err, result) {
        delete _this.pendings[key];
        if (err instanceof Object) {
          Object.freeze(err);
        }
        if (result instanceof Object) {
          Object.freeze(result);
        }
        return queue.forEach(function(item) {
          return item.callback.call(_this, err, result);
        });
      };
      try {
        exec.apply(null, __slice.call(args).concat([done]));
      } catch (_error) {
        err = _error;
        process.nextTick(function() {
          return done(err);
        });
      }
    };

    return MergePool;

  })();

  module.exports = MergePool;

}).call(this);

/*
//@ sourceMappingURL=merge_pool.map
*/
